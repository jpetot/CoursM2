dta = data(iris)
X = as.matrix(dta[1:10,1:4])
dta = data(iris[1:10,1:4])
dta = data(iris[1:10,1:4])
dta = data(iris[1:10,1:4])
install.packages("ggplot2")
library(ggplot2)
dta = data(iris[1:10,1:4])
library(ggplot2)
dta = data(iris)
head(iris)
dta = data(iris[,1:4])
data(iris)
dta = as.matrix(iris[,1:4])
dta = as.matrix(iris[1:10,1:4])
x = scale(x,scale = FALSE)
t(x) %*% x
x = as.matrix(iris[1:10,1:4])
x = scale(x,scale = FALSE)
t(x) %*% x
x %*% t(x)
cov = t(x) %*% x     # matrice des covariances
ps = x %*% t(x)     # matrice des produits scalaire
eignen(cov)
eigen(cov)
eigen(cov)
eigen(ps)
svd(X)
svd(x)
s = svd(x)
xchap = s$u[,1:2] %*% diag(s$d[1:2])%*% t(s$v[,1:2])
xchap
xchap = s$u[,1:j] %*% diag(s$d[1:j])%*% t(s$v[,1:j])
xchap = s$u[,1:j] %*% diag(s$d[1:j])%*% t(s$v[,1:j])
j=2
xchap = s$u[,1:j] %*% diag(s$d[1:j])%*% t(s$v[,1:j])
j=2
xchap = s$u[,1:j] %*% diag(s$d[1:j])%*% t(s$v[,1:j])
xchap
j=3
xchap = s$u[,1:j] %*% diag(s$d[1:j])%*% t(s$v[,1:j])
xchap
j=4
xchap = s$u[,1:j] %*% diag(s$d[1:j])%*% t(s$v[,1:j])
xchap
j=5
xchap = s$u[,1:j] %*% diag(s$d[1:j])%*% t(s$v[,1:j])
xchap
sum(xchap - x)^2
xchap = s$u[,1:j] %*% diag(s$d[1:j])%*% t(s$v[,1:j])
xchap
j=2
xchap = s$u[,1:j] %*% diag(s$d[1:j])%*% t(s$v[,1:j])
xchap
sum(xchap - x)^2
j=3
xchap = s$u[,1:j] %*% diag(s$d[1:j])%*% t(s$v[,1:j])
xchap
sum(xchap - x)^2
j=4
xchap = s$u[,1:j] %*% diag(s$d[1:j])%*% t(s$v[,1:j])
xchap
sum(xchap - x)^2
j=2
xchap = s$u[,1:j] %*% diag(s$d[1:j])%*% t(s$v[,1:j])
xchap
sum((xchap - x)^2)
j=3
xchap = s$u[,1:j] %*% diag(s$d[1:j])%*% t(s$v[,1:j])
xchap
sum((xchap - x)^2)
j=4
xchap = s$u[,1:j] %*% diag(s$d[1:j])%*% t(s$v[,1:j])
xchap
sum((xchap - x)^2)
install.packages("FactMineR")
library(FactoMineR)
install.packages("FactoMineR")
x %*% s$v
pca = PCA(X, scale.unit = FALSE)
library(FactoMineR)
x %*% s$v
pca = PCA(X, scale.unit = FALSE)
pca = PCA(x, scale.unit = FALSE)
pca$ind$cord
pca$ind$coord
fichier <- "https://husson.github.io/MOOC_AnaDo/AnaDo_JeuDonnees_Nobel_avecMaths.csv"
Nobel <- read.table(fichier, header=TRUE, sep=";", row.names=1, check.names=FALSE)
Nobel <- Nobel[1:8,]
Nobel
acf = CA(Nobel)
pca = PCA(Nobel)
install.packages("FactoShiny")
install.packages("Factoshiny")
library(Factoshiny)
Nobel
library(FactoMineR)
data(tea)
don <- tea[, c(14,18)]
TabCont <- table(don)
TabCont
don
MCA(don)
FCA(don)
MCA(don)
CA(TabCont)
#require(roxygen2)
#require(devtools)
require(microbenchmark)
setwd("~/M2/Cours_Agro_J1_Programmation_R/TD")
sapply(data,2,class())
sapply(data,2,class)
apply(data,2,class)
type(data)
data <- read.table("flights14.csv", sep = ",", header = TRUE)
head(data)
type(data)
apply(data,2,class)
sapply(data,2,class)
apply(data,2,class)
sapply(colnames(data), class)
#mean
apply(data,2,mean)
summary(data)
#mean
apply(data,1,mean)
#mean
apply(data,2,mean)
summary(data)
mean(data)
mean(data$mean)
sapply(colnames(data), class)
#mean
apply(data,2,as.numeric)
summary(data)
apply(data,2,mean)
sapply(colnames(data), class)
apply(data,2,class)
sapply(data, class)
apply(data,2,class)
sapply(data, class)
#mean
apply(data,2,mean)
#mean
sapply(data,mean)
data$arr_time[1:10] <- NA
sapply(data,mean)
apply(data,2,mean)
sapply(data, class)
#mean
sapply(data,mean)
apply(data,2,mean)
#mean
sapply(data,mean)
warnings()
apply(data,2,mean)
warnings()
apply(data[,typecol == "integer"],2,mean)
typeCol = sapply(data, class)
apply(data[, typeCol == "integer"],2,mean)
data$arr_time[1:10] <- NA
apply(data[, typeCol == "integer"],2,mean)
sapply(data,mean)
apply(data[, typeCol == "integer"],2,mean)
apply(data[, typeCol == "integer"],2,mean, na.rm=TRUE)
apply(data, 2, c(mean,max,min))
apply(data[, typeCol == "integer"],2,mean, na.rm=TRUE)
multi = function(x){
return(c(min, mean, max))
}
apply(data, 2,multi)
apply(data[, typeCol == "integer"], 2,multi)
multi = function(x){
return(c(min, mean, max))
}
sapply(data[, typeCol == "integer"], multi)
apply(data[, typeCol == "integer"],2, multi)
apply(data[, typeCol == "integer"],2, multi)
sapply(data[, typeCol == "integer"], multi)
multi = function(x){
return(c(min = min(x), mean = mean(x), max = max(x)))
}
sapply(data[, typeCol == "integer"], multi)
apply(data[, typeCol == "integer"],2, multi)
apply(data[, typeCol == "integer"],2,function(x)c(min = min(x), max = max(x), mean = mean(x)) )
apply(data[, typeCol == "integer"],2 , function(x) c(min = min(x), max = max(x), mean = mean(x)) ,na.rm = TRUE )
multi = function(x, ...){
return(c(min = min(x), mean = mean(x), max = max(x)))
}
apply(data[, typeCol == "integer"],2, multi)
apply(data[, typeCol == "integer"],2 , function(x, ...) c(min = min(x), max = max(x), mean = mean(x))
,na.rm = TRUE )
apply(data[, typeCol == "integer"],2, multi, na.rm = TRUE)
?paste)
?paste
paste0(1:12)
paste(1:12)        # same
as.character(1:12)
1:12
sapply(data[, typeCol == "integer"], function(x, ...) c(min = min(x), max = max(x), mean = mean(x)))
itinary = paste(data$origin, data$dest)
itinary
data$itinary = paste(data$origin, data$dest)
multi = function(x, na.remove = TRUE){
return(c(min = min(x, na.rm = na.remove), mean = mean(x, na.rm = na.remove),
max = max(x, na.rm = na.remove)))
}
apply(data[, typeCol == "integer"],2, multi, na.remove = TRUE)
multi = function(x, na.remove = TRUE){
return(c(min = min(x, na.rm = na.remove), max = max(x, na.rm = na.remove)))
}
apply(data[, typeCol == "integer"],2, multi, na.remove = TRUE)
summary(data)
tapply(data$air_time, INDEX = list(data$itinary), FUN = function(x) c(std = sd(x), mean = mean(x)))
tapply(data$air_time, INDEX = list(data$itinary), FUN = function(x) c(std = sd(x), mean = mean(x), count = count(x)))
tapply(data$air_time, INDEX = list(data$itinary), FUN = function(x) c(std = sd(x), mean = mean(x), count = length(x)))
?aggregate
aggregate(tapply(data$air_time, INDEX = list(data$itinary), FUN = function(x) c(std = sd(x), mean = mean(x), count = length(x))))
res = tapply(data$air_time, INDEX = list(data$itinary), FUN = function(x) c(std = sd(x), mean = mean(x), count = length(x)))
res = aggregate(res)
aggregate(data$itinary)
aggregate(state.x77, list(Region = state.region), mean)
res = tapply(data$air_time, INDEX = list(data$itinary), FUN = function(x) c(std = sd(x), mean = mean(x), count = length(x)))
res = tapply(data$air_time, INDEX = list(data$itinary), FUN = function(x) c(std = sd(x), mean = mean(x), count = length(x)))
res
# question 7
res = tapply(data$air_time, INDEX = list(data$itinary), FUN = function(x) c(std = sd(x), mean = mean(x), count = length(x), cv = sd(x)/mean(x)))
aggregate(data$itinary)
res
names(res)[which.max(res$cv)]
names(res)[,which.max(res$cv)]
class(res)
max = max(sapply(res,function(x)[3]))
max = max(sapply(res,function(x)[3])
(sapply(res,function(x)[3]
sapply(res,function(x)[3])
sapply(res,function(x) x[3])
max = max(sapply(res,function(x) x[3]) )
max
cv = max(sapply(res,function(x) x[3]) )
names[which.max(cv)]
cv[which.max(cv)]
names(cv[which.max(cv)])
names(cv)[which.max(cv)]
cv[which.max(cv)]
cv
cv = sapply(res,function(x) x[3])
cv
cv[which.max(cv)]
names(cv)[which.max(cv)]
cv[which.max(cv)]
parallel::detectCores()
require(parallel)
nb.cores <- detectCores() # 4
nb.cores
# mieux vaut éviter d'utiliser toutes les ressources
cl <- makeCluster(nb.cores - 1)
res <- clusterApply(cl, 1:7, function(x){ rnorm(x)})
str(res)
# mieux vaut éviter d'utiliser toutes les ressources
cl <- makeCluster(nb.cores - 5)
res <- clusterApply(cl, 1:7, function(x){ rnorm(x)})
str(res)
# mieux vaut éviter d'utiliser toutes les ressources
cl <- makeCluster(nb.cores - 5)
res <- clusterApply(cl, 1:7, function(x){ rnorm(x)})
str(res)
stopCluster(cl)
# mieux vaut éviter d'utiliser toutes les ressources
cl <- makeCluster(nb.cores - 5)
res <- clusterApply(cl, 1:7, function(x){ rnorm(x)})
str(res)
stopCluster(cl)
